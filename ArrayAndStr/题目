1、非递减数列合并
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

思路：
    1、先合并两个数组，再sort
    2、双指针
        逆序遍历；两个数组，比较大小交换，取较大的逆序填入目的数组

mergeSortedVector

2、数组删除部分元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。
假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：
更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。
返回 k。

输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。

思路：快排思路
    两层循环，左边找第一个非val，右边找第一个val，找到后交换位置
    
removeElement

3、给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：

更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。
返回 k 。

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]

思路：双指针
    i每次在前面，j每次在右边，每次找到一个不相等的赋值一下，注意别超过数组长度

removeDuplicates

4、有序数组删除重复元素
给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?envType=study-plan-v2&envId=top-interview-150

示例 1：
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。

思路：和上一题差不多，就是找重复的时候从后往前看，从前往后看的话不知道下一个元素一样是不是真正的相等的元素，答案是向前看的话一定是排序好的

removeDuplicates2

5、查找数量过半元素
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150

示例 1：
输入：nums = [3,2,3]
输出：3

思路：过半元素的次数累加累减

majorityElement

6、顺时针乱转数组

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150

思路：数组分组反转实现位移
    翻转3次，全数组翻转，分组翻转

rotate


7、股票买卖时机-找最大波段
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-interview-150

示例 1：
输入：[7,1,5,3,6,4]
输出：5

思路：动态规划
    每次遍历基于和目前最低价格差值算作的最大盈利

maxProfit

8、股票买卖时机2-所有波段
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

示例 1：
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solutions/12625/best-time-to-buy-and-sell-stock-ii-zhuan-hua-fa-ji/?envType=study-plan-v2&envId=top-interview-150

思路：贪心
    只有今天相比昨天有盈利就加进去

maxProfitSum

9、数组连续跳跃
给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

示例 1：
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标

思路：贪心
    遍历数组，一个变量表示人的位置，另一个变量表示路连续的最大长度(从当前点往后调一下最远距离)，因为人是连续遍历说明一定能跳到这里

canJump

10、最小跳跃次数

示例 1:
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150

思路：贪心
    每次记录本轮最远跳跃位置和所有元素的最远位置
    次数+1：只有本次走到本轮最大位置更新次数+1，表示本轮能走的最远位置已经走完

jumpMinTimes

11、最多有n个大于等于n的数
示例 1：

输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。

思路：排序+遍历（没啥意思）
先排序，找到值>=后面位置数量的下标

hIndex

12、实现random类
实现RandomizedSet 类：
RandomizedSet() 初始化 RandomizedSet 对象
bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。

https://leetcode.cn/problems/insert-delete-getrandom-o1/?envType=study-plan-v2&envId=top-interview-150

思路：哈希表
    为实现时间复杂度O（1）,需要一个hash表，unsorted_map存储键值对

RandomizedSet

13、数组除自身外元素的乘积-禁用除法
给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。
请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150

示例 1:

输入: nums = [1,2,3,4]
输出: [24,12,8,6]

思路：动态规划、数组划分
    每个数的除自己外的乘积就是左边的乘积*右边的乘积，因此先遍历两次记下每个点对应左边乘积和右边乘积

productExceptSelf

14、加油站
在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

示例 1:
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3

思路：遍历
两个数组的差位每个点开到下个点的收益或损耗，只要总和大于等于0表示可以转一圈

canCompleteCircuit

15、按分数分配糖果

https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。
你需要按照以下要求，给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

示例 1：
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。

思路：贪心算法+遍历 
    其实每个元素只需要跟自己的左右相邻比较就行，因此左右各遍历一次，分别计算我这个人单侧比较应该有几个，然后取最大值

candy

16、最后一个单词的长度
给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大
子字符串
 

示例 1：

输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为 5。


思路：从后往前遍历

lengthOfLastWord

17、最长的公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 ""。

 
示例 1：
输入：strs = ["flower","flow","flight"]
输出："fl"

思路：遍历 

longestCommonPrefix

18、翻转字符串的单词

给你一个字符串 s ，请你反转字符串中 单词 的顺序。
单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。
注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

 

示例 1：

输入：s = "the sky is blue"
输出："blue is sky the"

思路： 双指针
    逆序遍历找开始结尾，然后拷贝到新字符串

reverseWords

√19、接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

思路：单调栈
    是一个递减栈，可以找上一个最大的值

https://leetcode.cn/problems/trapping-rain-water/description/

trap

20、Z字型变换
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P   A   H   N
A P L S I I G
Y   I   R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

思路：遍历 
    其实就只输着一行一行遍历，每次赛一个，最后在按照行输出

convertZ

21、查找字符串子串
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。

示例 1：

输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。

思路：遍历、指针

strStr

22、居中展示
this   is  tree

思路：
int a = diff / (num-1)  // 前num-2个元素后面跟a个空格
int b = diff % (num-1)  // 倒数第2个元素后面跟b个空格

DiffAve

23、回文字符串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。

字母和数字都属于字母数字字符。

给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。

 

示例 1：

输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。

思路：双指针

isPalindrome

24、判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

思路：双指针 

25、两数之和
给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。
以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。
你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。
你所设计的解决方案必须只使用常量级的额外空间。

 
示例 1：
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。

思路：
1、双指针，首尾对向
2、哈希表，因为只有两个数，因此只要找剩余数是否在哈希表即可

twoSum

26、最大面积（盛水最多）
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

思路：双指针
    两端双指针一定是短板往里，才有可能变大

maxArea

27、3数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

示例 1
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。

思路：三指针
    固定a，b、c按照双指针对向遍历

threeSum

28、长度最小子数组
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 
子数组
 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

思路：滑动窗口
    每次右端点右移1位，左端点右移多次直到满足条件
    每次和大于目标值时，要循环把左侧移动到值小于目标值

minSubArrayLen

29、最长无重复子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串的长度。

示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

思路：滑动窗口
    每次右端点右移1位，左端点满足条件时跳跃更新
    左侧更新时机。每次重复时更新为上一次出现的位置

lengthOfLongestSubstring

30、最小涵盖子串
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
注意
对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
 
示例 1：
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

思路：滑动窗口 
    同28题
    每次右端点右移1次，左端点要右移到最小多次

minWindow

31、字符串是否可以重新构建

给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
如果可以，返回 true ；否则返回 false 。
magazine 中的每个字符只能在 ransomNote 中使用一次。

示例 1：
输入：ransomNote = "a", magazine = "b"
输出：false

思路：哈希表 
字符数量够就好

canConstruct

32、同构字符串

给定两个字符串 s 和 t ，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

示例 1:
输入：s = "egg", t = "add"
输出：true

思路：哈希表 
遍历，哈希表记录每个字母上次出现的位置，两个字符串一直比较就好

isIsomorphic

33、单词规律
给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。
这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。

示例1:
输入: pattern = "abba", s = "dog cat cat dog"
输出: true

思路：哈希表
和32题一样，只不过这里是字符串

wordPattern

34、字母异位词
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词

示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

思路：哈希表 
每个字母出现的次数相等就好
1、两个map都加完比较
2、一个+一个-

isAnagram

35、字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
字母异位词 是由重新排列源单词的所有字母得到的一个新单词。

示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

思路：哈希表
key为排序好的字符串

groupAnagrams


36、快乐数

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

示例 1：
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

思路：哈希表、快慢指针
其实就是不要进入死循环即可

isHappy

37、重复元素间隔

给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。

示例 1：
输入：nums = [1,2,3,1], k = 3
输出：true

思路：双指针 

containsNearbyDuplicate

38、最长连续序列
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

 
示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

思路：哈希表 
后面有多少个

longestConsecutive

39、汇总区间
给定一个  无重复元素 的 有序 整数数组 nums 。
返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。
列表中的每个区间范围 [a,b] 应该按如下格式输出：
"a->b" ，如果 a != b
"a" ，如果 a == b
 

示例 1：
输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"

思路：双指针

summaryRanges

40、合并区间
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

示例 1：
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

思路：双指针+贪心 
先以值1排序，再每次找到值2最大的点，在插入

merge

41、插入后合并区间
示例 1：

输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]

思路：双指针+贪心
和56差不多

insert

42、射气球最少箭

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

 
示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。

思路：贪心 
维护一个最小区间，每次尽可能的多放一些进去，知道没有交集再另开一个区间

findMinArrowShots

43、判断有效的括号

示例 1：
输入：s = "()"
输出：true

思路：栈

isValid

44、最小栈
设计一个栈类，任何时候可以直接返回最小值

思路：最小栈
辅助栈一直记录当前最小值

MinStack

45、逆波兰表达式

给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。
请你计算该表达式。返回一个表示表达式值的整数。
有效的算符为 '+'、'-'、'*' 和 '/' 。
每个操作数（运算对象）都可以是一个整数或者另一个表达式。
两个整数之间的除法总是 向零截断 。
表达式中不含除零运算。
输入是一个根据逆波兰表示法表示的算术表达式。
答案及所有中间计算结果可以用 32 位 整数表示。
 

示例 1：

输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

思路：栈 

evalRPN

46、简单加减计算器
示例 
输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23

思路：栈 
每次遇到（时把左边的符号整体入栈，括号内元素都结合这个符号直接运算，遇到）时符号出栈

47、判断环形链表
给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

思路：快慢指针 
步数不一

hasCycle

48、两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

addTwoNumbers

49、合并两个有序链表
mergeTwoLists

50、反转链表
给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]

思路：指针遍历
reverseBetween

51、删除链表倒数第n个节点
思路：双指针同时移动
ListNode* removeNthFromEnd(ListNode* head, int n)

52、删除链表中重复元素
思路：指针遍历，每次往后判断两个；注意本题是只要是重复元素直接删掉，而不是去重
deleteDuplicates

53、旋转链表
给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]

思路：找到分隔点
rotateRight

54、LRU缓存
实现最近最小使用
思路：一个哈希表表示有哪些元素，控制容量；指向一个双链表，表头为最近使用

55、二叉树最大深度
思路：
1、DFS 后序遍历 递归或者栈 
2、BFS 层次遍历 队列
int maxDepth(TreeNode* root)

56、相同的树
思路：递归遍历
bool isSameTree(TreeNode* p, TreeNode* q);

57、翻转二叉树
思路：递归遍历
invertTree

58、对称二叉树
思路：递归遍历,深度优先
左子树的左子树==右子树的右子树 && 左子树的右子树==右子树的左子树，一直深度优先遍历完一只在去判断另一个
bool isSymmetric(TreeNode* root)

59、从前序和中序遍历中构建二叉树
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]

思路：递归+hashmap 利用中序遍历知道左右子树数量
前序遍历是（根-左-右）、中序遍历是（左根右）
前序的第一个是根，可以从中序中划分成左右子树，那也就知道左右子树的数量了
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder);

60、从中序和后序遍历中构建二叉树
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
思路：递归+hashmap 利用中序遍历知道左右子树数量
后续最后一个是根，从中序中划分左右子树
buildTree2

61、路径长度
找一条路径值的和等于目标值
思路：递归 深度优先
hasPathSum

62、计算二叉树节点数
思路：递归遍历
int countNodes(TreeNode* root)

63、填充二叉树节点的next
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
类似B+数每个叶子节点指向同层的下一个
思路：层次遍历（广度优先遍历），把没层次的遍历一次
connect

64、二叉树前序遍历展开为链表
思路：递归+先序遍历 把左子树右下角的next链接为右子树
void flatten(TreeNode* root)

65、二叉树根节点到叶子节点数字拼接之和
思路：dfs+递归或者栈输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25

int sumNumbers(TreeNode* root)

66、二叉树最近公共祖先
思路：dfs
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)

67、二叉树的最大路径和
思路：递归，每次比较两种情况
int maxPathSum(TreeNode* root)

68、二叉树的右视图
返回二叉树每层的组右边节点
思路1：层次遍历 每次只记录这一层最后一个
思路2：深度优先遍历，先遍历右子树，每新增一层的时候右子树先行
vector<int> rightSideView(TreeNode* root)

69、计算二叉树每层的平均值
思路：层次遍历，每次遍历完这一层
vector<double> averageOfLevels(TreeNode* root)

70、二叉树层次遍历
每一层返回一个vector
vector<vector<int>> levelOrder(TreeNode* root)

71、二叉树z型遍历
思路：层次遍历的基础上，奇数层翻转一下 reverse(vec.begin(), vec.end())
vector<vector<int>> zigzagLevelOrder(TreeNode* root)

72、二叉搜索树找两个节点最小差值
思路：二叉搜索树的中序遍历就是有序递增的
int getMinimumDifference(TreeNode* root)；

73、验证二叉搜索树
思路：二叉搜索树的中序遍历应该是有序递增的
bool isValidBST(TreeNode* root)

74、二叉搜索树实现迭代器
思路：搞一个数组直接存，构造函数的时候实现一次遍历

75、二叉搜索树种的第k小元素
思路：深度优先遍历（中序遍历即可）
int kthSmallest(TreeNode* root, int k)

76、岛屿数量
思路：递归即可，把所有连接的都置为0
int numIslands(vector<vector<char>>& grid)

77、包围问题
思路：76类似 但是边缘不算 临时替代
void solve(vector<vector<char>>& board)

78、课程表 依赖关系
思路：每个点分3个状态 0-未访问 1-正在访问该环 2-访问完
bool canFinish(int numCourses, vector<vector<int>>& prerequisites);

79、课程表2
返回学习顺序
vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites)
思想：一个双层数组记录每门课后可以学哪些课（邻居），另一个记录每门课的入度数量（学这门课前需要学几门）

80、分治二叉搜索树
TreeNode* sortedArrayToBST(vector<int>& nums)
